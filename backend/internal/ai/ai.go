package ai

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"backend/internal/database"

	"github.com/google/generative-ai-go/genai"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"google.golang.org/api/option"
)

// ComplexityResult holds the structured complexity analysis from the AI model.
type ComplexityResult struct {
	TimeComplexity   string `json:"time_complexity"`
	MemoryComplexity string `json:"memory_complexity"`
}

// CompletionCacheEntry defines the schema for the cache in MongoDB.
type CompletionCacheEntry struct {
	ID         string    `bson:"_id"`
	Suggestion string    `bson:"suggestion"`
	CreatedAt  time.Time `bson:"createdAt"`
}

// Define a struct for the expected JSON response from the AI.
type AICompletionResponse struct {
	Suggestion string `json:"suggestion"`
}

// Define a type for sample test case
type SampleTestCase struct {
	Input          string `json:"input"`
	ExpectedOutput string `json:"expected_output"`
}

// ProblemDetails represents structured problem information generated by AI
type ProblemDetails struct {
	Title              string   `json:"title"`
	FormattedStatement string   `json:"formatted_statement"`
	Difficulty         string   `json:"difficulty"`
	Constraints        string   `json:"constraints"`
	Tags               []string `json:"tags"`
	ProblemID          string   `json:"problem_id"`
}

var client *genai.Client
var model *genai.GenerativeModel
var completionCacheCollection *mongo.Collection

// InitAIClient initializes the Gemini client.
func InitAIClient(ctx context.Context) error {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return fmt.Errorf("GEMINI_API_KEY environment variable not set")
	}

	var err error
	client, err = genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return fmt.Errorf("failed to create genai client: %w", err)
	}

	// Initialize the model
	model = client.GenerativeModel("gemini-2.0-flash")

	// Initialize the database collection for caching
	completionCacheCollection = database.GetCollection("OJ", "completion_cache")

	// Ensure TTL index on the cache collection
	if err := ensureCacheTTLIndex(ctx); err != nil {
		return fmt.Errorf("failed to ensure cache TTL index: %w", err)
	}

	return nil
}

// ensureCacheTTLIndex creates a TTL index on the `createdAt` field.
func ensureCacheTTLIndex(ctx context.Context) error {
	indexModel := mongo.IndexModel{
		Keys:    bson.D{{Key: "createdAt", Value: 1}},
		Options: options.Index().SetExpireAfterSeconds(3600), // Expire after 1 hour
	}
	_, err := completionCacheCollection.Indexes().CreateOne(ctx, indexModel)
	if err != nil {
		// Ignore if the index already exists, but log other errors.
		if !strings.Contains(err.Error(), "index already exists") {
			return fmt.Errorf("failed to create TTL index: %w", err)
		}
		log.Println("TTL index on completion_cache already exists.")
	}
	return nil
}

// GenerateStructuredOutput uses Gemini to generate structured output based on a provided schema
func GenerateStructuredOutput(ctx context.Context, prompt string, schema *genai.Schema) (string, error) {
	if client == nil {
		return "", fmt.Errorf("AI client not initialized")
	}

	// Create a model for structured output
	structuredModel := client.GenerativeModel("gemini-2.0-flash")

	// Configure for structured output
	structuredModel.ResponseMIMEType = "application/json"
	structuredModel.ResponseSchema = schema

	// Generate the content
	resp, err := structuredModel.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return "", fmt.Errorf("failed to generate structured content: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("no content in AI response")
	}

	// Extract the text content
	textContent, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return "", fmt.Errorf("AI response is not text")
	}

	return string(textContent), nil
}

// GenerateStructuredProblemDetails generates problem details with a structured schema
func GenerateStructuredProblemDetails(ctx context.Context, rawProblemStatement string) (*ProblemDetails, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define the schema for problem details
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"title":               {Type: genai.TypeString},
			"formatted_statement": {Type: genai.TypeString},
			"difficulty":          {Type: genai.TypeString, Enum: []string{"Easy", "Medium", "Hard"}},
			"constraints":         {Type: genai.TypeString},
			"tags": {
				Type:  genai.TypeArray,
				Items: &genai.Schema{Type: genai.TypeString},
			},
			"problem_id": {Type: genai.TypeString},
		},
		Required: []string{"title", "formatted_statement", "difficulty", "constraints", "tags", "problem_id"},
	}

	// Create a prompt for the AI to generate problem details
	prompt := fmt.Sprintf(`
You are an expert in competitive programming problems. Based on the raw problem statement provided,
generate a well-structured problem with appropriate details.

Raw problem statement:
"""
%s
"""

Create a complete problem with the following elements:

1. Title: A concise, descriptive title for the problem.
2. Formatted Statement: A well-structured problem statement with clear descriptions, examples, and explanations.
3. Difficulty: Categorize as "Easy", "Medium", or "Hard" based on algorithmic complexity and expected solution time.
4. Constraints: Technical constraints for input parameters (e.g., array length limits, value ranges).
5. Tags: 2-4 relevant algorithmic tags (e.g., "Array", "Dynamic Programming", "Graph", "Binary Search", etc.).
6. Problem ID: A kebab-case identifier derived from the title (e.g., "two-sum" for "Two Sum").
`, rawProblemStatement)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured problem details: %w", err)
	}

	// Unmarshal the JSON string into a struct
	var problemDetails ProblemDetails
	if err := json.Unmarshal([]byte(jsonOutput), &problemDetails); err != nil {
		return nil, fmt.Errorf("failed to parse problem details JSON: %w", err)
	}

	return &problemDetails, nil
}

// GenerateStructuredTestCases generates test cases with a structured schema
func GenerateStructuredTestCases(ctx context.Context, problemStatement string) (map[string]interface{}, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define a schema with an array of test cases
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"test_cases": {
				Type:        genai.TypeArray,
				Description: "An array of exactly 30 test cases",
				Items: &genai.Schema{
					Type: genai.TypeObject,
					Properties: map[string]*genai.Schema{
						"name":   {Type: genai.TypeString},
						"input":  {Type: genai.TypeString},
						"python": {Type: genai.TypeBoolean},
					},
					Required: []string{"name", "input"},
				},
			},
		},
		Required: []string{"test_cases"},
	}

	// Read the test case generator prompt template
	promptTemplate, err := os.ReadFile("testcase_generator.txt")
	if err != nil {
		return nil, fmt.Errorf("failed to read test case generator template: %w", err)
	}

	// Replace the problem statement placeholder in the template
	prompt := strings.Replace(string(promptTemplate), "{PROBLEM_STATEMENT}", problemStatement, 1)

	// Add additional instruction to emphasize generating 30 test cases
	prompt += "\n\nIMPORTANT: You MUST generate exactly 30 test cases in the test_cases array. Each test case should have a 'name' field (like 'test_case_1'), an 'input' field, and optionally a 'python' field."

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured test cases: %w", err)
	}

	// Log the raw response for debugging (truncated for readability)
	log.Printf("Raw AI response for test cases: %s", truncateForLogging(jsonOutput, 1000))

	// Process the output to handle Python expressions
	jsonOutput = fixPythonExpressions(jsonOutput)
	log.Printf("JSON after fixing Python expressions: %s", truncateForLogging(jsonOutput, 1000))

	// Unmarshal the JSON string into a struct with the test cases array
	var result struct {
		TestCases []struct {
			Name   string `json:"name"`
			Input  string `json:"input"`
			Python bool   `json:"python"`
		} `json:"test_cases"`
	}

	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		log.Printf("JSON unmarshal failed: %v", err)
		return nil, fmt.Errorf("failed to parse test cases JSON: %w", err)
	}

	// Convert the array to a map of test cases
	testCases := make(map[string]interface{})
	for _, tc := range result.TestCases {
		testCases[tc.Name] = map[string]interface{}{
			"input":  tc.Input,
			"python": tc.Python,
		}
	}

	// Check if we have enough test cases
	if len(testCases) < 30 {
		log.Printf("Warning: Generated only %d test cases instead of 30", len(testCases))
	}

	return testCases, nil
}

// AnalyzeCodeComplexity uses the AI model to determine the time and memory complexity of a code snippet.
func AnalyzeCodeComplexity(ctx context.Context, code string, language string) (*ComplexityResult, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define schema for complexity analysis
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"time_complexity":   {Type: genai.TypeString},
			"memory_complexity": {Type: genai.TypeString},
		},
		Required: []string{"time_complexity", "memory_complexity"},
	}

	prompt := fmt.Sprintf(`
        You are an expert algorithm analyst.
        Analyze the following code snippet and provide its time and memory complexity in Big O notation.

        Language: %s
        Code:
        ---
        %s
        ---
    `, language, code)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured complexity analysis: %w", err)
	}

	// Unmarshal the JSON string into a struct
	var result ComplexityResult
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return nil, fmt.Errorf("failed to parse complexity analysis JSON: %w", err)
	}

	return &result, nil
}

func cleanAIResponse(resp string) (string, error) {
	// Clean the response by removing markdown backticks and "python" language identifier
	cleaned := strings.TrimSpace(resp)
	cleaned = strings.TrimPrefix(cleaned, "```python")
	cleaned = strings.TrimPrefix(cleaned, "```")
	cleaned = strings.TrimSuffix(cleaned, "```")
	return strings.TrimSpace(cleaned), nil
}

// ConvertPseudocodeToPython uses the AI model to convert pseudocode into runnable Python code.
func ConvertPseudocodeToPython(ctx context.Context, pseudocode string) (string, error) {
	if client == nil {
		return "", fmt.Errorf("AI client not initialized")
	}

	// Define schema for Python code output
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"python_code": {Type: genai.TypeString},
		},
		Required: []string{"python_code"},
	}

	prompt := "You are an expert programmer specializing in converting pseudocode to clean, runnable Python code. " +
		"Your task is to translate the given pseudocode into a single, complete Python script.\n\n" +
		"**Instructions:**\n" +
		"1. **Direct Translation:** Convert the user's logic as directly as possible. Do not add new features, algorithms, or logic that are not explicitly mentioned in the pseudocode.\n" +
		"2. **Helper Function Generation:** If the user includes a comment like \"# define binary search\" or \"# implement DFS\", you MUST generate the standard, efficient Python implementation for that specific algorithm as a helper function. The function signature should be inferred from the context if possible. Only generate code for these explicitly requested, well-known algorithms.\n" +
		"3. **No Main Solution:** Do NOT generate the main solution logic (e.g., the main `twoSum` function in a Two Sum problem). Only generate the helper functions as described above. The user is responsible for writing the main logic.\n" +
		"4. **Clean Output:** Return the Python code in the python_code field.\n\n" +
		"**Pseudocode to Convert:**\n" +
		"---\n" +
		pseudocode +
		"\n---"

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return "", fmt.Errorf("failed to generate content for pseudocode conversion: %w", err)
	}

	// Unmarshal the JSON string
	var result struct {
		PythonCode string `json:"python_code"`
	}
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return "", fmt.Errorf("failed to parse pseudocode conversion JSON: %w", err)
	}

	return result.PythonCode, nil
}

func GetCodeCompletion(prefix, currentLine, language string, problemName string, sampleTestCase *SampleTestCase) (string, error) {
	ctx := context.Background()

	// Create a unique cache key from the inputs.
	// Include problemName in the cache key if available
	cacheKeyBase := fmt.Sprintf("lang:%s|prefix:%s|current:%s", language, prefix, currentLine)
	cacheKey := cacheKeyBase
	if problemName != "" {
		cacheKey = fmt.Sprintf("%s|problem:%s", cacheKeyBase, problemName)
	}

	// 1. Check database cache first
	var cachedEntry CompletionCacheEntry
	err := completionCacheCollection.FindOne(ctx, bson.M{"_id": cacheKey}).Decode(&cachedEntry)
	if err == nil {
		// Found in cache
		log.Printf("Cache hit for key: %s", cacheKey)
		return cachedEntry.Suggestion, nil
	}
	if err != mongo.ErrNoDocuments {
		log.Printf("Error checking cache: %v", err)
		// Proceed without cache, but log the error.
	}

	// Define schema for code completion
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"suggestion": {Type: genai.TypeString},
		},
		Required: []string{"suggestion"},
	}

	// Create the base prompt
	promptBuilder := strings.Builder{}
	promptBuilder.WriteString("You are an intelligent code completion assistant. Your task is to complete the code provided by the user.\n")
	promptBuilder.WriteString("You will be given the code that appears before the cursor, and the content of the current line up to the cursor.\n")
	promptBuilder.WriteString("Based on this context, provide the most logical and likely code completion.\n\n")

	promptBuilder.WriteString("**Instructions:**\n")
	promptBuilder.WriteString("1. The completion can be a single line or multiple lines of code.\n")
	promptBuilder.WriteString("2. Respond with a JSON object containing a single key: \"suggestion\". The value should be the code to be inserted at the cursor position.\n")
	promptBuilder.WriteString("3. If the new code should start from a new line, ADD a newline character at the beginning of the suggestion string.\n")
	promptBuilder.WriteString("4. Do NOT repeat any code that was already provided in the 'Code before cursor' or 'Current line' sections in your suggestion.\n")
	promptBuilder.WriteString("5. Return only the suggestion in the structured format.\n")
	promptBuilder.WriteString("6. DO NOT autocomplete the main task, you may provide completion for helper functions or give function signatures for main function.\n")

	promptBuilder.WriteString("---CONTEXT---\n")
	promptBuilder.WriteString(fmt.Sprintf("Language: %s\n\n", language))

	// Add problem name if available
	if problemName != "" {
		promptBuilder.WriteString(fmt.Sprintf("Problem Name: %s\n\n", problemName))
	}

	// Add sample test case if available
	if sampleTestCase != nil {
		promptBuilder.WriteString("Sample Test Case:\n")
		promptBuilder.WriteString(fmt.Sprintf("Input:\n```\n%s\n```\n\n", sampleTestCase.Input))
		promptBuilder.WriteString(fmt.Sprintf("Expected Output:\n```\n%s\n```\n\n", sampleTestCase.ExpectedOutput))
	}

	promptBuilder.WriteString(fmt.Sprintf("Code before cursor:\n```\n%s\n```\n\n", prefix))
	promptBuilder.WriteString(fmt.Sprintf("Current line:\n```\n%s\n```\n\n", currentLine))

	prompt := promptBuilder.String()

	log.Printf("Sending prompt to AI for completion:\n%s", prompt)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return "", fmt.Errorf("gemini API call failed: %w", err)
	}

	// Unmarshal the JSON string
	var result AICompletionResponse
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		log.Printf("Failed to unmarshal AI completion response: %s", jsonOutput)
		// Fallback: maybe the model returned raw code despite instructions
		if strings.Contains(err.Error(), "invalid character") {
			return jsonOutput, nil // return the cleaned text as a fallback
		}
		return "", fmt.Errorf("failed to parse AI response JSON: %w", err)
	}

	suggestion := result.Suggestion
	log.Printf("AI response: %s", suggestion)

	// Set to cache on successful response
	if suggestion != "" {
		newEntry := CompletionCacheEntry{
			ID:         cacheKey,
			Suggestion: suggestion,
			CreatedAt:  time.Now(),
		}
		_, err := completionCacheCollection.InsertOne(ctx, newEntry)
		if err != nil {
			log.Printf("Failed to cache completion suggestion: %v", err)
		} else {
			log.Printf("Cached suggestion for key: %s", cacheKey)
		}
	}

	return suggestion, nil
}

// GenerateHintContent uses the AI model to generate a hint based on the provided prompt
func GenerateHintContent(ctx context.Context, prompt string) (*genai.GenerateContentResponse, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate content for hint: %w", err)
	}

	return resp, nil
}

// GenerateProgressiveHints generates a set of 3 progressive hints for a problem
// Each hint provides more guidance than the previous one
func GenerateProgressiveHints(ctx context.Context, problemStatement, code, language string) ([]string, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define schema for hints
	schema := &genai.Schema{
		Type: genai.TypeArray,
		Items: &genai.Schema{
			Type: genai.TypeString,
		},
		Description: "An array of three progressive hints, from subtle to more specific",
	}

	// Create a prompt for the AI to generate progressive hints
	prompt := fmt.Sprintf(`
You are an expert programming tutor who specializes in giving helpful hints without revealing full solutions.
Based on the problem statement and the user's current code, provide THREE progressive hints that will guide them 
toward the solution without giving away the complete answer.

Problem Statement:
"""
%s
"""

User's Current Code (%s):
"""
%s
"""

Please provide 3 progressive hints, each building on the previous one:

1. Hint 1: A subtle clue about the approach or a gentle nudge toward the key insight needed.
   This should be vague but useful, focusing on conceptual understanding.

2. Hint 2: A more specific suggestion that builds on the first hint, possibly pointing out
   a particular algorithm or data structure that might be helpful.

3. Hint 3: A more detailed hint that gives clearer direction without providing the full solution.
   This may include a specific approach or technique but still leaves implementation details for the user.
`, problemStatement, language, code)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		if err.Error() == "AI client not initialized" {
			return []string{
				"AI service is not available at the moment. Please try again later.",
				"AI service is not available at the moment. Please try again later.",
				"AI service is not available at the moment. Please try again later.",
			}, nil
		}
		return nil, err
	}

	// Unmarshal the JSON array
	var hints []string
	if err := json.Unmarshal([]byte(jsonOutput), &hints); err != nil {
		log.Printf("Failed to unmarshal hints: %s", jsonOutput)
		return []string{
			"Sorry, I couldn't generate hints at this time. Please try again later.",
			"Sorry, I couldn't generate hints at this time. Please try again later.",
			"Sorry, I couldn't generate hints at this time. Please try again later.",
		}, nil
	}

	// Make sure we have exactly 3 hints
	if len(hints) < 3 {
		for len(hints) < 3 {
			hints = append(hints, "Sorry, I couldn't generate a complete set of hints. Try a different approach.")
		}
	}

	return hints[:3], nil
}

// EvaluatePythonTestCases processes test cases and evaluates any Python expressions
func EvaluatePythonTestCases(testCasesData map[string]interface{}) map[string]interface{} {
	// Get the test cases array
	testCasesArray, ok := testCasesData["test_cases"].([]interface{})
	if !ok {
		log.Println("Failed to parse test_cases as array")
		return testCasesData
	}

	// Process each test case
	for i, testCase := range testCasesArray {
		testCaseMap, ok := testCase.(map[string]interface{})
		if !ok {
			continue
		}

		// Check if this is a Python test case
		isPython, ok := testCaseMap["python"].(bool)
		if !ok || !isPython {
			// Also check for string inputs that look like Python expressions
			inputStr, ok := testCaseMap["input"].(string)
			if !ok || !containsPythonExpression(inputStr) {
				continue
			}
		}

		// Get the input string
		inputStr, ok := testCaseMap["input"].(string)
		if !ok {
			continue
		}

		// Evaluate the Python expression
		evaluatedInput := EvaluatePythonExpression(inputStr)

		// Update the test case with the evaluated input
		testCaseMap["input"] = evaluatedInput

		// Remove the python flag as it's now been evaluated
		delete(testCaseMap, "python")

		// Update the test case in the array
		testCasesArray[i] = testCaseMap
	}

	// Update the test cases in the original data
	testCasesData["test_cases"] = testCasesArray

	log.Println("Successfully evaluated Python expressions in test cases")
	return testCasesData
}

// containsPythonExpression checks if a string contains Python-like expressions
func containsPythonExpression(input string) bool {
	// Check for string multiplication patterns
	if strings.Contains(input, "*") || strings.Contains(input, "+") {
		// Check for quoted strings
		if strings.Contains(input, "'") || strings.Contains(input, "\"") {
			return true
		}
	}
	return false
}

// EvaluatePythonExpression evaluates common Python string expressions
func EvaluatePythonExpression(expr string) string {
	// Handle empty string concatenation with repeated string: ''+'abcdef'*833
	emptyPlusPattern := regexp.MustCompile(`^''?\+['"]([^'"]+)['"][ ]*\*[ ]*(\d+)$`)
	if matches := emptyPlusPattern.FindStringSubmatch(expr); len(matches) == 3 {
		str := matches[1]
		count, err := strconv.Atoi(matches[2])
		if err == nil {
			// Limit repetition to avoid memory issues
			if count > 50000000/len(str) {
				count = 50000000 / len(str)
			}
			return strings.Repeat(str, count)
		}
	}

	// Handle simple string repetition: 'abcdef'*833
	simpleMultPattern := regexp.MustCompile(`^['"]([^'"]+)['"][ ]*\*[ ]*(\d+)$`)
	if matches := simpleMultPattern.FindStringSubmatch(expr); len(matches) == 3 {
		str := matches[1]
		count, err := strconv.Atoi(matches[2])
		if err == nil {
			// Limit repetition to avoid memory issues
			if count > 50000000/len(str) {
				count = 50000000 / len(str)
			}
			return strings.Repeat(str, count)
		}
	}

	// Handle string concatenation: 'abc' + 'def'
	concatPattern := regexp.MustCompile(`^['"]([^'"]+)['"][ ]*\+[ ]*['"]([^'"]+)['"]$`)
	if matches := concatPattern.FindStringSubmatch(expr); len(matches) == 3 {
		return matches[1] + matches[2]
	}

	// If we can't evaluate it, return the original expression
	log.Printf("Could not evaluate Python expression: %s", expr)
	return expr
}

// GenerateTestCases uses the AI model to generate test cases for a problem
func GenerateTestCases(ctx context.Context, problemStatement string) (map[string]interface{}, error) {
	// Try the structured approach first
	testCases, err := GenerateStructuredTestCases(ctx, problemStatement)
	if err != nil {
		log.Printf("Structured test case generation failed: %v", err)
		// Fall back to the original approach
		testCases, err = generateTestCasesOriginal(ctx, problemStatement)
		if err != nil {
			return nil, err
		}
	}

	// If we didn't get enough test cases, fall back to the original approach
	if len(testCases) < 15 { // If we got less than half of the expected test cases
		log.Printf("Structured approach only generated %d test cases, falling back to original approach", len(testCases))
		testCases, err = generateTestCasesOriginal(ctx, problemStatement)
		if err != nil {
			return nil, err
		}
	}

	// Evaluate any Python expressions in the test cases
	testCases = EvaluatePythonTestCases(testCases)

	return testCases, nil
}

// generateTestCasesOriginal is the original implementation of test case generation without structured output
func generateTestCasesOriginal(ctx context.Context, problemStatement string) (map[string]interface{}, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Read the test case generator prompt template
	promptTemplate, err := os.ReadFile("testcase_generator.txt")
	if err != nil {
		return nil, fmt.Errorf("failed to read test case generator template: %w", err)
	}

	// Replace the problem statement placeholder in the template
	prompt := strings.Replace(string(promptTemplate), "{PROBLEM_STATEMENT}", problemStatement, 1)

	// Generate the test cases using the AI model
	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate test cases: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content in AI response for test case generation")
	}

	// Extract the JSON response
	jsonContent, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return nil, fmt.Errorf("AI response is not text")
	}

	// Log the raw response for debugging (truncated for readability)
	log.Printf("Raw AI response for test cases: %s", truncateForLogging(string(jsonContent), 1000))

	// Clean the response: extract JSON object from the response
	cleanedJSON := strings.TrimSpace(string(jsonContent))

	// Remove markdown code block markers and any text before or after the JSON
	cleanedJSON = strings.ReplaceAll(cleanedJSON, "```json", "")
	cleanedJSON = strings.ReplaceAll(cleanedJSON, "```", "")

	// Find the JSON object in the response
	startIdx := strings.Index(cleanedJSON, "{")
	endIdx := strings.LastIndex(cleanedJSON, "}")

	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		log.Printf("Failed to extract JSON object from response: %s", truncateForLogging(cleanedJSON, 500))
		return nil, fmt.Errorf("failed to extract JSON from AI response")
	}

	jsonStr := cleanedJSON[startIdx : endIdx+1]

	// Log the extracted JSON for debugging (truncated for readability)
	log.Printf("Extracted JSON for test cases: %s", truncateForLogging(jsonStr, 1000))

	// First, try to fix Python expressions in the JSON
	jsonStr = fixPythonExpressions(jsonStr)
	log.Printf("JSON after fixing Python expressions: %s", truncateForLogging(jsonStr, 1000))

	// Unmarshal the JSON string into a map
	var testCases map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &testCases); err != nil {
		log.Printf("First JSON unmarshal attempt failed: %v", err)

		// If standard unmarshaling fails, try a more robust approach
		// by manually cleaning up the JSON
		cleanedJsonStr := cleanJSONString(jsonStr)
		log.Printf("Cleaned JSON for test cases: %s", truncateForLogging(cleanedJsonStr, 1000))

		if err := json.Unmarshal([]byte(cleanedJsonStr), &testCases); err != nil {
			log.Printf("Second JSON unmarshal attempt failed: %v", err)
			return nil, fmt.Errorf("failed to parse test cases JSON: %w", err)
		}

		log.Printf("JSON parsing succeeded after cleaning")
	}

	return testCases, nil
}

// GenerateBruteForceSolution uses the AI model to generate an accurate brute force solution
// for a given problem statement, prioritizing correctness over efficiency
func GenerateBruteForceSolution(ctx context.Context, problemStatement string, language string) (string, error) {
	if client == nil {
		return "", fmt.Errorf("AI client not initialized")
	}

	// Define schema for solution code
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"solution_code": {Type: genai.TypeString},
		},
		Required: []string{"solution_code"},
	}

	// Create a prompt that emphasizes correctness over efficiency
	prompt := fmt.Sprintf(`
You are an expert algorithm engineer tasked with implementing a solution to a coding problem.

## Problem Statement
%s

## Requirements
1. PRIORITIZE CORRECTNESS OVER EFFICIENCY. Your solution MUST be 100%% correct.
2. Use a brute force approach if necessary to ensure correctness.
3. Include comprehensive error handling and edge case handling.
4. Your solution must handle all possible inputs within the constraints.
5. Include clear comments explaining your approach.
6. Return the solution code in %s in the solution_code field of your response.

## Important Notes
- DO NOT optimize prematurely. Efficiency is NOT a concern.
- Handle all edge cases explicitly.
- If multiple approaches exist, choose the SIMPLEST and most STRAIGHTFORWARD one.
- Include test cases in comments if it helps ensure correctness.
- Make sure your solution works for all valid inputs, including edge cases.
`, problemStatement, language)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema)
	if err != nil {
		return "", fmt.Errorf("failed to generate brute force solution: %w", err)
	}

	// Unmarshal the JSON string
	var result struct {
		SolutionCode string `json:"solution_code"`
	}
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return "", fmt.Errorf("failed to parse solution JSON: %w", err)
	}

	return result.SolutionCode, nil
}

// GenerateExpectedOutputs uses a reference solution to generate expected outputs for test cases
func GenerateExpectedOutputs(ctx context.Context, problemStatement string, testCases map[string]interface{}, language string) (map[string]string, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// First, generate a brute force reference solution
	referenceSolution, err := GenerateBruteForceSolution(ctx, problemStatement, language)
	if err != nil {
		return nil, fmt.Errorf("failed to generate reference solution: %w", err)
	}

	// Log the reference solution for debugging
	log.Printf("Generated reference solution (%d characters): %s", len(referenceSolution), truncateForLogging(referenceSolution, 200))

	// Prepare a map to store the expected outputs
	expectedOutputs := make(map[string]string)

	// Extract test case inputs
	for testName, testData := range testCases {
		testCase, ok := testData.(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("invalid test case format for %s", testName)
		}

		input, ok := testCase["input"].(string)
		if !ok {
			return nil, fmt.Errorf("invalid input format for test case %s", testName)
		}

		// Log the test case input for debugging
		log.Printf("Test case %s input (%d characters): %s", testName, len(input), truncateForLogging(input, 100))

		// Check if this is a Python-generated input
		isPython, _ := testCase["python"].(bool)
		if isPython {
			// For Python-generated inputs, we need to evaluate them
			// This would be handled by the executor service
			// For now, we'll just mark them as requiring evaluation
			expectedOutputs[testName] = "<requires-python-evaluation>"
			continue
		}

		// For regular inputs, we'll use the executor service to run the reference solution
		// This would be implemented in a separate function that calls the executor service
		// For now, we'll just mark them as requiring execution
		expectedOutputs[testName] = "<requires-execution>"
	}

	// Return the expected outputs (which would be populated by the executor service)
	return expectedOutputs, nil
}

// GenerateProblemDetails uses the AI model to generate structured problem details
func GenerateProblemDetails(ctx context.Context, rawProblemStatement string) (*ProblemDetails, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Create a prompt for the AI to generate problem details
	prompt := fmt.Sprintf(`
You are an expert in competitive programming problems. Based on the raw problem statement provided,
generate a well-structured problem with appropriate details.

Raw problem statement:
"""
%s
"""

Create a complete problem with the following elements:

1. Title: A concise, descriptive title for the problem.
2. Formatted Statement: A well-structured problem statement with clear descriptions, examples, and explanations.
3. Difficulty: Categorize as "Easy", "Medium", or "Hard" based on algorithmic complexity and expected solution time.
4. Constraints: Technical constraints for input parameters (e.g., array length limits, value ranges).
5. Tags: 2-4 relevant algorithmic tags (e.g., "Array", "Dynamic Programming", "Graph", "Binary Search", etc.).
6. Problem ID: A kebab-case identifier derived from the title (e.g., "two-sum" for "Two Sum").

Format your response as a JSON object with these exact keys:
{
  "title": "Problem Title",
  "formatted_statement": "Clear problem statement with examples",
  "difficulty": "Easy|Medium|Hard",
  "constraints": "1 <= n <= 10^5\\n-10^9 <= nums[i] <= 10^9",
  "tags": ["Tag1", "Tag2"],
  "problem_id": "kebab-case-id"
}
`, rawProblemStatement)

	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate problem details: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content in AI response for problem details generation")
	}

	// Extract the JSON response
	jsonContent, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return nil, fmt.Errorf("AI response is not text")
	}

	// Clean the response: extract JSON object from the response
	cleanedJSON := strings.TrimSpace(string(jsonContent))

	// Find the JSON object in the response
	startIdx := strings.Index(cleanedJSON, "{")
	endIdx := strings.LastIndex(cleanedJSON, "}")

	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		return nil, fmt.Errorf("failed to extract JSON from AI response")
	}

	jsonStr := cleanedJSON[startIdx : endIdx+1]

	// Unmarshal the JSON string into a struct
	var problemDetails ProblemDetails
	if err := json.Unmarshal([]byte(jsonStr), &problemDetails); err != nil {
		return nil, fmt.Errorf("failed to parse problem details JSON: %w", err)
	}

	// Validate essential fields
	if problemDetails.Title == "" || problemDetails.FormattedStatement == "" || problemDetails.Difficulty == "" {
		return nil, fmt.Errorf("AI generated incomplete problem details")
	}

	// Ensure difficulty is one of the expected values
	problemDetails.Difficulty = strings.Title(strings.ToLower(problemDetails.Difficulty))
	if problemDetails.Difficulty != "Easy" && problemDetails.Difficulty != "Medium" && problemDetails.Difficulty != "Hard" {
		problemDetails.Difficulty = "Medium" // Default to Medium if unexpected value
	}

	// Generate problem ID if not provided or invalid
	if problemDetails.ProblemID == "" {
		// Convert title to kebab-case
		problemDetails.ProblemID = strings.ToLower(problemDetails.Title)
		problemDetails.ProblemID = strings.ReplaceAll(problemDetails.ProblemID, " ", "-")
		// Remove any non-alphanumeric characters except hyphens
		reg := regexp.MustCompile("[^a-z0-9-]")
		problemDetails.ProblemID = reg.ReplaceAllString(problemDetails.ProblemID, "")
		// Replace multiple hyphens with a single one
		reg = regexp.MustCompile("-+")
		problemDetails.ProblemID = reg.ReplaceAllString(problemDetails.ProblemID, "-")
		// Trim hyphens from start and end
		problemDetails.ProblemID = strings.Trim(problemDetails.ProblemID, "-")
	}

	return &problemDetails, nil
}

// truncateForLogging truncates a long string for logging purposes
func truncateForLogging(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}

	// Keep the first and last parts of the string
	firstPart := maxLen / 2
	lastPart := maxLen / 2

	return s[:firstPart] + "..." + s[len(s)-lastPart:]
}

// fixPythonExpressions handles Python expressions in the test cases JSON
// by marking them as Python-generated and simplifying the input
func fixPythonExpressions(jsonStr string) string {
	// Detect complex Python expressions (list comprehensions, join, etc.)
	reComplexPython := regexp.MustCompile(`"input"\s*:\s*"('.*?join\(.*?\)|.*?for\s+.*?\s+in\s+.*?)"`)
	jsonStr = reComplexPython.ReplaceAllString(jsonStr, `"input": "$1", "python": true`)

	// Handle string repetition with concatenation in quotes (e.g., 'a' * 100000 + 'b')
	reQuotedMultConcat := regexp.MustCompile(`"input"\s*:\s*"'([^']+)'\s*\*\s*(\d+)\s*\+\s*'([^']+)'"`)
	jsonStr = reQuotedMultConcat.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the strings and repetition count
		parts := reQuotedMultConcat.FindStringSubmatch(match)
		if len(parts) < 4 {
			return match
		}

		// Parse the repetition count
		count, err := strconv.Atoi(parts[2])
		if err != nil {
			return match
		}

		// Limit the repetition to avoid memory issues (50MB max)
		if count > 50000000/len(parts[1]) {
			count = 50000000 / len(parts[1])
		}

		// Generate the repeated string and concatenate
		repeated := strings.Repeat(parts[1], count) + parts[3]

		// Return the evaluated result
		return fmt.Sprintf(`"input": "%s"`, repeated)
	})

	// Handle string repetition in quotes (e.g., 'a' * 100000)
	reQuotedMult := regexp.MustCompile(`"input"\s*:\s*"'([^']+)'\s*\*\s*(\d+)"`)
	jsonStr = reQuotedMult.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the string and repetition count
		parts := reQuotedMult.FindStringSubmatch(match)
		if len(parts) < 3 {
			return match
		}

		// Parse the repetition count
		count, err := strconv.Atoi(parts[2])
		if err != nil {
			return match
		}

		// Limit the repetition to avoid memory issues (50MB max)
		if count > 50000000/len(parts[1]) {
			count = 50000000 / len(parts[1])
		}

		// Generate the repeated string
		repeated := strings.Repeat(parts[1], count)

		// Return the evaluated result
		return fmt.Sprintf(`"input": "%s"`, repeated)
	})

	// Handle string concatenation first (more complex pattern)
	reConcat := regexp.MustCompile(`"input"\s*:\s*"([^"]+)"\s*\*\s*\d+\s*\+\s*"([^"]+)"\s*\*\s*\d+`)
	jsonStr = reConcat.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the strings
		parts := reConcat.FindStringSubmatch(match)
		if len(parts) < 3 {
			return match
		}

		// Replace with a simplified version and set python flag to true
		return fmt.Sprintf(`"input": "%s%s", "python": true`, parts[1], parts[2])
	})

	// Then handle simple string multiplication
	reMult := regexp.MustCompile(`"input"\s*:\s*"([^"]+)"\s*\*\s*\d+`)
	jsonStr = reMult.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the string
		parts := reMult.FindStringSubmatch(match)
		if len(parts) < 2 {
			return match
		}

		// Replace with a simplified version and set python flag to true
		return fmt.Sprintf(`"input": "%s", "python": true`, parts[1])
	})

	// Remove any existing python: false that might still be present
	jsonStr = regexp.MustCompile(`"python"\s*:\s*false`).ReplaceAllString(jsonStr, "")

	// Clean up any double commas that might have been created
	jsonStr = regexp.MustCompile(`,\s*,`).ReplaceAllString(jsonStr, ",")

	// Fix trailing commas before closing braces
	jsonStr = regexp.MustCompile(`,\s*\}`).ReplaceAllString(jsonStr, "}")

	// Fix trailing commas before closing brackets
	jsonStr = regexp.MustCompile(`,\s*\]`).ReplaceAllString(jsonStr, "]")

	// Handle any other invalid characters that might appear in the JSON
	jsonStr = regexp.MustCompile(`[^\x20-\x7E]`).ReplaceAllString(jsonStr, "")

	return jsonStr
}

// cleanJSONString attempts to clean up a JSON string that might have formatting issues
func cleanJSONString(jsonStr string) string {
	// Replace common issues that might cause parsing errors

	// Handle Python string multiplication (e.g., "a" * 50000)
	re := regexp.MustCompile(`"([^"]+)"\s*\*\s*(\d+)`)
	jsonStr = re.ReplaceAllString(jsonStr, `"$1"`)

	// Handle Python string concatenation (e.g., "a" * 25000 + "b" * 25000)
	re = regexp.MustCompile(`"([^"]+)"\s*\+\s*"([^"]+)"`)
	jsonStr = re.ReplaceAllString(jsonStr, `"$1$2"`)

	// Replace any sequence of * characters that might appear in comments
	jsonStr = regexp.MustCompile(`\*+`).ReplaceAllString(jsonStr, "")

	// Remove any trailing commas in objects and arrays which are invalid in JSON
	jsonStr = regexp.MustCompile(`,\s*\}`).ReplaceAllString(jsonStr, "}")
	jsonStr = regexp.MustCompile(`,\s*\]`).ReplaceAllString(jsonStr, "]")

	// Fix common quote issues with boolean values
	jsonStr = strings.ReplaceAll(jsonStr, `"python": True`, `"python": true`)
	jsonStr = strings.ReplaceAll(jsonStr, `"python": False`, `"python": false`)

	// Handle any other invalid characters that might appear in the JSON
	jsonStr = regexp.MustCompile(`[^\x20-\x7E]`).ReplaceAllString(jsonStr, "")

	return jsonStr
}
