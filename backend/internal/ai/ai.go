package ai

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"backend/internal/database"
	"backend/internal/models"

	"github.com/google/generative-ai-go/genai"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"google.golang.org/api/option"
)

// ComplexityResult holds the structured complexity analysis from the AI model.
type ComplexityResult struct {
	TimeComplexity   string `json:"time_complexity"`
	MemoryComplexity string `json:"memory_complexity"`
}

// CompletionCacheEntry defines the schema for the cache in MongoDB.
type CompletionCacheEntry struct {
	ID         string    `bson:"_id"`
	Suggestion string    `bson:"suggestion"`
	CreatedAt  time.Time `bson:"createdAt"`
}

// Define a struct for the expected JSON response from the AI.
type AICompletionResponse struct {
	Suggestion string `json:"suggestion"`
}

// Define a type for sample test case
type SampleTestCase struct {
	Input          string `json:"input"`
	ExpectedOutput string `json:"expected_output"`
}

// ProblemDetails represents structured problem information generated by AI
type ProblemDetails struct {
	Title              string   `json:"title"`
	FormattedStatement string   `json:"formatted_statement"`
	Difficulty         string   `json:"difficulty"`
	Constraints        string   `json:"constraints"`
	Tags               []string `json:"tags"`
	ProblemID          string   `json:"problem_id"`
}

// BruteForceSolution holds the generated solution code and function name
type BruteForceSolution struct {
	SolutionCode string `json:"solution_code"`
	FunctionName string `json:"function_name"`
}

// IOParseResult holds the code for parsing I/O and the function signature.
type IOParseResult struct {
	InputParserCode   string `json:"input_parser_code"`
	FunctionSignature string `json:"function_signature"`
	OutputParserCode  string `json:"output_parser_code"`
}

var client *genai.Client
var model *genai.GenerativeModel
var completionCacheCollection *mongo.Collection

// InitAIClient initializes the Gemini client.
func InitAIClient(ctx context.Context) error {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return fmt.Errorf("GEMINI_API_KEY environment variable not set")
	}

	var err error
	client, err = genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return fmt.Errorf("failed to create genai client: %w", err)
	}

	// Initialize the model
	model = client.GenerativeModel("gemini-2.0-flash")

	// Initialize the database collection for caching
	completionCacheCollection = database.GetCollection("OJ", "completion_cache")

	// Ensure TTL index on the cache collection
	if err := ensureCacheTTLIndex(ctx); err != nil {
		return fmt.Errorf("failed to ensure cache TTL index: %w", err)
	}

	return nil
}

// ensureCacheTTLIndex creates a TTL index on the `createdAt` field.
func ensureCacheTTLIndex(ctx context.Context) error {
	indexModel := mongo.IndexModel{
		Keys:    bson.D{{Key: "createdAt", Value: 1}},
		Options: options.Index().SetExpireAfterSeconds(3600), // Expire after 1 hour
	}
	_, err := completionCacheCollection.Indexes().CreateOne(ctx, indexModel)
	if err != nil {
		// Ignore if the index already exists, but log other errors.
		if !strings.Contains(err.Error(), "index already exists") {
			return fmt.Errorf("failed to create TTL index: %w", err)
		}
		log.Println("TTL index on completion_cache already exists.")
	}
	return nil
}

// GenerateStructuredOutput uses Gemini to generate structured output based on a provided schema
func GenerateStructuredOutput(ctx context.Context, prompt string, schema *genai.Schema, temperature float32) (string, error) {
	if client == nil {
		return "", fmt.Errorf("AI client not initialized")
	}

	// Create a model for structured output
	structuredModel := client.GenerativeModel("gemini-2.0-flash")

	// Configure for structured output
	structuredModel.ResponseMIMEType = "application/json"
	structuredModel.ResponseSchema = schema
	structuredModel.Temperature = &temperature

	// Generate the content
	resp, err := structuredModel.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return "", fmt.Errorf("failed to generate structured content: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("no content in AI response")
	}

	// Extract the text content
	textContent, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return "", fmt.Errorf("AI response is not text")
	}

	return string(textContent), nil
}

// GenerateStructuredProblemDetails generates problem details with a structured schema
func GenerateStructuredProblemDetails(ctx context.Context, rawProblemStatement string) (*ProblemDetails, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define the schema for problem details
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"title":               {Type: genai.TypeString},
			"formatted_statement": {Type: genai.TypeString},
			"difficulty":          {Type: genai.TypeString, Enum: []string{"Easy", "Medium", "Hard"}},
			"constraints":         {Type: genai.TypeString},
			"tags": {
				Type:  genai.TypeArray,
				Items: &genai.Schema{Type: genai.TypeString},
			},
			"problem_id": {Type: genai.TypeString},
		},
		Required: []string{"title", "formatted_statement", "difficulty", "constraints", "tags", "problem_id"},
	}

	// Create a prompt for the AI to generate problem details
	prompt := fmt.Sprintf(`
You are an expert in competitive programming problems. Based on the raw problem statement provided,
generate a well-structured problem with appropriate details.

Raw problem statement:
"""
%s
"""

Create a complete problem with the following elements:

1. Title: A concise, descriptive title for the problem.
2. Formatted Statement: A well-structured problem statement with a clear description, followed by 2-4 illustrative examples that clarify the problem's requirements and edge cases. Each example must have an input, the expected output, and a detailed explanation.
3. Difficulty: Categorize as "Easy", "Medium", or "Hard" based on algorithmic complexity and expected solution time.
4. Constraints: Technical constraints for input parameters (e.g., array length limits, value ranges).
5. Tags: 2-4 relevant algorithmic tags (e.g., "Array", "Dynamic Programming", "Graph", "Binary Search", etc.).
6. Problem ID: A kebab-case identifier derived from the title (e.g., "two-sum" for "Two Sum").
`, rawProblemStatement)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 1)
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured problem details: %w", err)
	}

	// Unmarshal the JSON string into a struct
	var problemDetails ProblemDetails
	if err := json.Unmarshal([]byte(jsonOutput), &problemDetails); err != nil {
		return nil, fmt.Errorf("failed to parse problem details JSON: %w", err)
	}

	problemDetails.ProblemID = createUniqueProblemID(problemDetails.ProblemID)

	return &problemDetails, nil
}

// createUniqueProblemID creates a unique problem ID by appending a timestamp and a random hex string.
func createUniqueProblemID(baseID string) string {
	randBytes := make([]byte, 4)
	if _, err := rand.Read(randBytes); err != nil {
		// fallback to just timestamp if rand fails
		return fmt.Sprintf("%s-%d", baseID, time.Now().UnixNano())
	}
	return fmt.Sprintf("%s-%d-%s", baseID, time.Now().UnixNano(), hex.EncodeToString(randBytes))
}

// GenerateStructuredTestCases generates test cases with a structured schema
func GenerateStructuredTestCases(ctx context.Context, problemStatement string, constraints string) ([]map[string]interface{}, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define a schema with an array of test cases
	schema := &genai.Schema{
		Type:        genai.TypeArray,
		Description: "An array of exactly 30 test cases.",
		Items: &genai.Schema{
			Type: genai.TypeObject,
			Properties: map[string]*genai.Schema{
				"id": {Type: genai.TypeInteger},
				"inputs": {
					Type:        genai.TypeArray,
					Description: "An array of objects, where each object represents an input parameter.",
					Items: &genai.Schema{
						Type: genai.TypeObject,
						Properties: map[string]*genai.Schema{
							"name":   {Type: genai.TypeString, Description: "The name of the parameter."},
							"data":   {Description: "The input value. Can be any valid JSON type or a Python expression string."},
							"python": {Type: genai.TypeBoolean, Description: "True if 'data' is a Python expression to be evaluated."},
						},
						Required: []string{"name", "data", "python"},
					},
				},
			},
			Required: []string{"id", "inputs"},
		},
	}

	// Read the test case generator prompt template
	promptTemplate, err := os.ReadFile("testcase_generator.txt")
	if err != nil {
		return nil, fmt.Errorf("failed to read test case generator template: %w", err)
	}

	// Combine problem statement and constraints for the prompt
	fullProblemContext := problemStatement
	if constraints != "" {
		fullProblemContext += "\n\nConstraints:\n" + constraints
	}

	// Replace the problem statement placeholder in the template
	prompt := strings.Replace(string(promptTemplate), "{PROBLEM_STATEMENT}", fullProblemContext, 1)

	// Add additional instruction to emphasize generating 30 test cases and a mix of difficulties
	prompt += "\n\nIMPORTANT: You MUST generate a JSON array of exactly 30 test case objects, with a good mix of easy, medium, and hard difficulty levels. Each test case should follow the specified schema.\n" +
		"Specifically, the \"inputs\" field MUST be an array of objects, where each object has \"name\", \"data\", and \"python\" fields. Do NOT use \"key = value\" strings in the \"inputs\" array directly. Use the specified object format for each parameter."

	log.Printf("Prompt for test cases: %s", prompt)
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0) // Temperature 0 for test cases
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured test cases: %w", err)
	}

	// Log the raw response for debugging (truncated for readability)
	log.Printf("Raw AI response for test cases: %s", TruncateForLogging(jsonOutput, 3000))

	// Unmarshal the JSON string into a slice of test case maps
	var testCases []map[string]interface{}
	if err := json.Unmarshal([]byte(jsonOutput), &testCases); err != nil {
		log.Printf("JSON unmarshal failed: %v", err)
		return nil, fmt.Errorf("failed to parse test cases JSON: %w", err)
	}

	// Check if we have enough test cases
	if len(testCases) < 30 {
		log.Printf("Warning: Generated only %d test cases instead of 30", len(testCases))
	}

	return testCases, nil
}

// AnalyzeCodeComplexity uses the AI model to determine the time and memory complexity of a code snippet.
func AnalyzeCodeComplexity(ctx context.Context, code string, language string) (*ComplexityResult, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define schema for complexity analysis
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"time_complexity":   {Type: genai.TypeString},
			"memory_complexity": {Type: genai.TypeString},
		},
		Required: []string{"time_complexity", "memory_complexity"},
	}

	prompt := fmt.Sprintf(`
        You are an expert algorithm analyst.
        Analyze the following code snippet and provide its time and memory complexity in Big O notation.

        Language: %s
        Code:
        ---
        %s
        ---
    `, language, code)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.2)
	if err != nil {
		return nil, fmt.Errorf("failed to generate structured complexity analysis: %w", err)
	}

	// Process the output to handle Python expressions
	jsonOutput = fixPythonExpressions(jsonOutput)
	log.Printf("JSON after fixing Python expressions: %s", TruncateForLogging(jsonOutput, 1000))

	// Unmarshal the JSON string into a struct
	var result ComplexityResult
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return nil, fmt.Errorf("failed to parse complexity analysis JSON: %w", err)
	}

	return &result, nil
}

// ConvertPseudocodeToPython uses the AI model to convert pseudocode into runnable Python code.
func ConvertPseudocodeToPython(ctx context.Context, pseudocode string) (string, error) {
	if client == nil {
		return "", fmt.Errorf("AI client not initialized")
	}

	// Define schema for Python code output
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"python_code": {Type: genai.TypeString},
		},
		Required: []string{"python_code"},
	}

	prompt := "You are an expert programmer specializing in converting pseudocode to clean, runnable Python code. " +
		"Your task is to translate the given pseudocode into a single, complete Python script.\n\n" +
		"**Instructions:**\n" +
		"1. **Direct Translation:** Convert the user's logic as directly as possible. Do not add new features, algorithms, or logic that are not explicitly mentioned in the pseudocode.\n" +
		"2. **Helper Function Generation:** If the user includes a comment like \"# define binary search\" or \"# implement DFS\", you MUST generate the standard, efficient Python implementation for that specific algorithm as a helper function. The function signature should be inferred from the context if possible. Only generate code for these explicitly requested, well-known algorithms.\n" +
		"3. **No Main Solution:** Do NOT generate the main solution logic (e.g., the main `twoSum` function in a Two Sum problem). Only generate the helper functions as described above. The user is responsible for writing the main logic.\n" +
		"4. **Clean Output:** Return the Python code in the python_code field.\n\n" +
		"**Pseudocode to Convert:**\n" +
		"---\n" +
		pseudocode +
		"\n---"

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.2)
	if err != nil {
		return "", fmt.Errorf("failed to generate content for pseudocode conversion: %w", err)
	}

	// Unmarshal the JSON string
	var result struct {
		PythonCode string `json:"python_code"`
	}
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return "", fmt.Errorf("failed to parse pseudocode conversion JSON: %w", err)
	}

	return result.PythonCode, nil
}

func GetCodeCompletion(prefix, currentLine, language string, problemName string, sampleTestCase *SampleTestCase) (string, error) {
	ctx := context.Background()

	// Create a unique cache key from the inputs.
	// Include problemName in the cache key if available
	cacheKeyBase := fmt.Sprintf("lang:%s|prefix:%s|current:%s", language, prefix, currentLine)
	cacheKey := cacheKeyBase
	if problemName != "" {
		cacheKey = fmt.Sprintf("%s|problem:%s", cacheKeyBase, problemName)
	}

	// 1. Check database cache first
	var cachedEntry CompletionCacheEntry
	err := completionCacheCollection.FindOne(ctx, bson.M{"_id": cacheKey}).Decode(&cachedEntry)
	if err == nil {
		// Found in cache
		log.Printf("Cache hit for key: %s", cacheKey)
		return cachedEntry.Suggestion, nil
	}
	if err != mongo.ErrNoDocuments {
		log.Printf("Error checking cache: %v", err)
		// Proceed without cache, but log the error.
	}

	// Define schema for code completion
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"suggestion": {Type: genai.TypeString},
		},
		Required: []string{"suggestion"},
	}

	// Create the base prompt
	promptBuilder := strings.Builder{}
	promptBuilder.WriteString("You are an intelligent code completion assistant. Your task is to complete the code provided by the user.\n")
	promptBuilder.WriteString("You will be given the code that appears before the cursor, and the content of the current line up to the cursor.\n")
	promptBuilder.WriteString("Based on this context, provide the most logical and likely code completion.\n\n")

	promptBuilder.WriteString("**Instructions:**\n")
	promptBuilder.WriteString("1. The completion can be a single line or multiple lines of code.\n")
	promptBuilder.WriteString("2. Respond with a JSON object containing a single key: \"suggestion\". The value should be the code to be inserted at the cursor position.\n")
	promptBuilder.WriteString("3. If the new code should start from a new line, ADD a newline character at the beginning of the suggestion string.\n")
	promptBuilder.WriteString("4. Do NOT repeat any code that was already provided in the 'Code before cursor' or 'Current line' sections in your suggestion.\n")
	promptBuilder.WriteString("5. Return only the suggestion in the structured format.\n")
	promptBuilder.WriteString("6. DO NOT autocomplete the main task, you may provide completion for helper functions or give function signatures for main function.\n")

	promptBuilder.WriteString("---CONTEXT---\n")
	promptBuilder.WriteString(fmt.Sprintf("Language: %s\n\n", language))

	// Add problem name if available
	if problemName != "" {
		promptBuilder.WriteString(fmt.Sprintf("Problem Name: %s\n\n", problemName))
	}

	// Add sample test case if available
	if sampleTestCase != nil {
		promptBuilder.WriteString("Sample Test Case:\n")
		promptBuilder.WriteString(fmt.Sprintf("Input:\n```\n%s\n```\n\n", sampleTestCase.Input))
		promptBuilder.WriteString(fmt.Sprintf("Expected Output:\n```\n%s\n```\n\n", sampleTestCase.ExpectedOutput))
	}

	promptBuilder.WriteString(fmt.Sprintf("Code before cursor:\n```\n%s\n```\n\n", prefix))
	promptBuilder.WriteString(fmt.Sprintf("Current line:\n```\n%s\n```\n\n", currentLine))

	prompt := promptBuilder.String()

	log.Printf("Sending prompt to AI for completion:\n%s", prompt)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.5)
	if err != nil {
		return "", fmt.Errorf("gemini API call failed: %w", err)
	}

	// Unmarshal the JSON string
	var result AICompletionResponse
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		log.Printf("Failed to unmarshal AI completion response: %s", jsonOutput)
		// Fallback: maybe the model returned raw code despite instructions
		if strings.Contains(err.Error(), "invalid character") {
			return jsonOutput, nil // return the cleaned text as a fallback
		}
		return "", fmt.Errorf("failed to parse AI response JSON: %w", err)
	}

	suggestion := result.Suggestion
	log.Printf("AI response: %s", suggestion)

	// Set to cache on successful response
	if suggestion != "" {
		newEntry := CompletionCacheEntry{
			ID:         cacheKey,
			Suggestion: suggestion,
			CreatedAt:  time.Now(),
		}
		_, err := completionCacheCollection.InsertOne(ctx, newEntry)
		if err != nil {
			log.Printf("Failed to cache completion suggestion: %v", err)
		} else {
			log.Printf("Cached suggestion for key: %s", cacheKey)
		}
	}

	return suggestion, nil
}

// GenerateHintContent uses the AI model to generate a hint based on the provided prompt
func GenerateHintContent(ctx context.Context, prompt string) (*genai.GenerateContentResponse, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate content for hint: %w", err)
	}

	return resp, nil
}

// GenerateProgressiveHints generates a set of 3 progressive hints for a problem
// Each hint provides more guidance than the previous one
func GenerateProgressiveHints(ctx context.Context, problemStatement, code, language string) ([]string, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define schema for hints
	schema := &genai.Schema{
		Type: genai.TypeArray,
		Items: &genai.Schema{
			Type: genai.TypeString,
		},
		Description: "An array of three progressive hints, from subtle to more specific",
	}

	// Create a prompt for the AI to generate progressive hints
	prompt := fmt.Sprintf(`
You are an expert programming tutor who specializes in giving helpful hints without revealing full solutions.
Based on the problem statement and the user's current code, provide THREE progressive hints that will guide them 
toward the solution without giving away the complete answer.

Problem Statement:
"""
%s
"""

User's Current Code (%s):
"""
%s
"""

Please provide 3 progressive hints, each building on the previous one:

1. Hint 1: A subtle clue about the approach or a gentle nudge toward the key insight needed.
   This should be vague but useful, focusing on conceptual understanding.

2. Hint 2: A more specific suggestion that builds on the first hint, possibly pointing out
   a particular algorithm or data structure that might be helpful.

3. Hint 3: A more detailed hint that gives clearer direction without providing the full solution.
   This may include a specific approach or technique but still leaves implementation details for the user.
`, problemStatement, language, code)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.7)
	if err != nil {
		if err.Error() == "AI client not initialized" {
			return []string{
				"AI service is not available at the moment. Please try again later.",
				"AI service is not available at the moment. Please try again later.",
				"AI service is not available at the moment. Please try again later.",
			}, nil
		}
		return nil, err
	}

	// Unmarshal the JSON array
	var hints []string
	if err := json.Unmarshal([]byte(jsonOutput), &hints); err != nil {
		log.Printf("Failed to unmarshal hints: %s", jsonOutput)
		return []string{
			"Sorry, I couldn't generate hints at this time. Please try again later.",
			"Sorry, I couldn't generate hints at this time. Please try again later.",
			"Sorry, I couldn't generate hints at this time. Please try again later.",
		}, nil
	}

	// Make sure we have exactly 3 hints
	if len(hints) < 3 {
		for len(hints) < 3 {
			hints = append(hints, "Sorry, I couldn't generate a complete set of hints. Try a different approach.")
		}
	}

	return hints[:3], nil
}

// EvaluatePythonTestCases processes test cases and evaluates any Python expressions
func EvaluatePythonTestCases(ctx context.Context, testCasesData []map[string]interface{}) []map[string]interface{} {
	// Process each test case
	for _, testCaseMap := range testCasesData {
		inputsRaw, ok := testCaseMap["inputs"].([]interface{})
		if !ok {
			log.Printf("Skipping test case due to invalid 'inputs' format, expected an array")
			continue
		}

		evaluatedInputs := make(map[string]interface{})
		for _, inputItem := range inputsRaw {
			paramDetails, ok := inputItem.(map[string]interface{})
			if !ok {
				log.Printf("Skipping an input parameter because it's not a valid object")
				continue
			}

			paramName, nameOk := paramDetails["name"].(string)
			data := paramDetails["data"]
			isPython, _ := paramDetails["python"].(bool)

			if !nameOk || paramName == "" {
				log.Printf("Skipping an input parameter due to missing or invalid 'name'")
				continue
			}

			if isPython {
				dataStr, isString := data.(string)
				if !isString {
					log.Printf("Parameter '%s' is marked for python evaluation but data is not a string. Using original.", paramName)
					evaluatedInputs[paramName] = data
					continue
				}

				evaluatedInput, err := EvaluatePythonExpression(ctx, dataStr)
				if err != nil {
					log.Printf("Failed to evaluate Python expression for key %s: %v. Using original.", paramName, err)
					evaluatedInputs[paramName] = dataStr
				} else {
					// Attempt to unmarshal the result, as it might be a JSON-like string (e.g., list)
					var decodedValue interface{}
					if err := json.Unmarshal([]byte(evaluatedInput), &decodedValue); err == nil {
						evaluatedInputs[paramName] = decodedValue
					} else {
						evaluatedInputs[paramName] = evaluatedInput
					}
				}
			} else {
				evaluatedInputs[paramName] = data
			}
		}
		testCaseMap["inputs"] = evaluatedInputs
	}
	return testCasesData
}

// // containsPythonExpression checks if a string contains Python-like expressions
// func containsPythonExpression(input string) bool {
// 	// Check for string multiplication patterns
// 	if strings.Contains(input, "*") || strings.Contains(input, "+") {
// 		// Check for quoted strings
// 		if strings.Contains(input, "'") || strings.Contains(input, "\"") {
// 			return true
// 		}
// 	}
// 	return false
// }

// EvaluatePythonExpression evaluates a Python expression by sending it to the executor service.
func EvaluatePythonExpression(ctx context.Context, expr string) (string, error) {
	log.Printf("Evaluating Python expression via executor: %s", TruncateForLogging(expr, 200))

	// Prepend 'import random' if the expression uses it and doesn't already import it.
	if strings.Contains(expr, "random.") && !strings.Contains(expr, "import random") {
		expr = "import random\n" + expr
	}

	// If the AI-provided expression doesn't contain a print statement, wrap it in one.
	// This ensures the value of the expression is captured by stdout.
	if !strings.Contains(expr, "print(") {
		expr = fmt.Sprintf("print(%s)", expr)
	}

	// Execute the code directly, assuming the executor captures stdout.
	// This avoids double-printing issues from a wrapping function.
	evaluated, err := ExecuteCodeInExecutor(ctx, expr, "python", "")
	if err != nil {
		return "", fmt.Errorf("evaluation via executor failed: %w", err)
	}

	log.Printf("Successfully evaluated expression to: %s", TruncateForLogging(evaluated, 100))
	return evaluated, nil
}

// GenerateTestCases uses the AI model to generate test cases for a problem
func GenerateTestCases(ctx context.Context, problemStatement string, constraints string) ([]map[string]interface{}, error) {
	// Try the structured approach first
	testCases, err := GenerateStructuredTestCases(ctx, problemStatement, constraints)
	if err != nil {
		log.Printf("Structured test case generation failed: %v", err)
		return nil, err
	}

	// If we didn't get enough test cases, fall back to the original approach
	if len(testCases) < 15 { // If we got less than half of the expected test cases
		log.Printf("Structured approach only generated %d test cases, falling back to original approach", len(testCases))
		return nil, fmt.Errorf("structured approach only generated less than 15 test cases")
	}

	// Evaluate any Python expressions in the test cases
	evaluatedTestCases := EvaluatePythonTestCases(ctx, testCases)

	return evaluatedTestCases, nil
}

// GenerateBruteForceSolution uses the AI model to generate an accurate brute force solution
// for a given problem statement, prioritizing correctness over efficiency
func GenerateBruteForceSolution(ctx context.Context, problemStatement string, language string, functionSignature string) (*BruteForceSolution, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Define schema for solution code
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"solution_code": {Type: genai.TypeString},
			"function_name": {Type: genai.TypeString},
		},
		Required: []string{"solution_code", "function_name"},
	}

	// Create a prompt that emphasizes correctness over efficiency
	prompt := fmt.Sprintf(`
You are an expert algorithm engineer tasked with implementing a solution to a coding problem in python.

## Problem Statement
%s

## Requirements
1. Implement the logic for the function with the following signature: %s.
2. PRIORITIZE CORRECTNESS OVER EFFICIENCY. Your solution MUST be 100%% correct.
3. Use a brute force approach if necessary to ensure correctness.
4. The entire solution must be contained within the provided function signature.
5. Your solution must handle all possible inputs within the constraints.
6. Return a JSON object with "solution_code" (containing only the function body) and "function_name" (which should be "solve").


## Important Notes
- DO NOT optimize prematurely. Efficiency is NOT a concern.
- The function should be standalone and not rely on any class structure unless absolutely necessary for the language (like Java).
- Return a JSON object with "solution_code" and "function_name" fields.
- If multiple approaches exist, choose the SIMPLEST and most STRAIGHTFORWARD one.
- Make sure your solution works for all valid inputs, including edge cases.
`, problemStatement, functionSignature)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.1)
	if err != nil {
		return nil, fmt.Errorf("failed to generate brute force solution: %w", err)
	}

	// Unmarshal the JSON string
	var result BruteForceSolution
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return nil, fmt.Errorf("failed to parse solution JSON: %w", err)
	}

	// Ensure the function name is 'solve' as requested.
	result.FunctionName = "solve"

	return &result, nil
}

// GenerateCorrectSolution uses the AI model to generate a correct solution
// for a given problem statement, prioritizing correctness over efficiency.
func GenerateCorrectSolution(ctx context.Context, problemStatement string, language string, functionSignature string) (*BruteForceSolution, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"solution_code": {Type: genai.TypeString},
			"function_name": {Type: genai.TypeString},
		},
		Required: []string{"solution_code", "function_name"},
	}

	prompt := fmt.Sprintf(`
You are an expert algorithm engineer tasked with implementing a solution to a coding problem in python.

## Problem Statement
%s

## Requirements
1. Implement the logic for the function with the following signature: %s.
2. The function should be correct and handle all edge cases described in the problem.
3. The entire solution must be contained within the provided function signature.
4. Return a JSON object with "solution_code" (containing only the function body) and "function_name" (which should be "solve").

## Important Notes
- Your primary goal is correctness. Ensure the solution works for all valid inputs.
- The function should be standalone and not rely on any class structure unless absolutely necessary for the language (like Java).
`, problemStatement, functionSignature)

	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.1)
	if err != nil {
		return nil, fmt.Errorf("failed to generate correct solution: %w", err)
	}

	var result BruteForceSolution
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return nil, fmt.Errorf("failed to parse solution JSON: %w", err)
	}

	return &result, nil
}

func createFunctionName(title string) string {
	// Convert to lowercase
	name := strings.ToLower(title)
	// Replace spaces with underscores
	name = strings.ReplaceAll(name, " ", "_")
	// Remove all non-alphanumeric characters except underscores
	reg := regexp.MustCompile("[^a-z0-9_]+")
	name = reg.ReplaceAllString(name, "")
	// Ensure it's a valid identifier (e.g., not starting with a number)
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		name = "_" + name
	}
	return name
}

// GenerateIOParseCode generates code to parse input, a function signature, and code to format output.
func GenerateIOParseCode(ctx context.Context, testCaseInputs []string, language string, problemTitle string, statementExamples string) (*IOParseResult, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Sanitize problemID to be a valid function name
	funcName := createFunctionName(problemTitle)

	// Define the schema for the I/O parsing code result
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"input_parser_code":  {Type: genai.TypeString},
			"function_signature": {Type: genai.TypeString},
			"output_parser_code": {
				Type:        genai.TypeString,
				Description: fmt.Sprintf("The code that takes the return value from '%s', which will be called with the parsed variables, and prints the result to standard output in the correct format. Do not include the function's implementation; only call the function and print its return value.", funcName),
			},
		},
		Required: []string{"input_parser_code", "function_signature", "output_parser_code"},
	}

	// Create the prompt
	prompt := fmt.Sprintf(`
You are an expert programmer. Your task is to write code that parses a raw JSON string input into variables for a function, defines the function signature, and then formats the function's output back into a string.

You will be given two sets of examples:
1. **Statement Examples**: These are from the problem description and show the high-level input/output format. The input here is NOT JSON.
2. **JSON Input Examples**: These show the specific JSON format your parser will receive from stdin. Your generated 'input_parser_code' must handle this JSON format.

Language: %s

Statement Examples:
---
%s
---

JSON Input Examples:
---
%s
---

Based on these examples, generate a JSON object with three fields:
1. "input_parser_code": The code that reads a single line from standard input (stdin), which will be a JSON string. This code must parse the JSON into variables required by the solution function. For Python, use the 'json' library.
2. "function_signature": The signature of the function that will solve the problem. Name the function '%s'. It should take the parsed variables as arguments.
3. "output_parser_code": The code that takes the return value from '%s', which will be called with the parsed variables, and prints the result to standard output in the correct format. Do not include the function's implementation; only call the function and print its return value.

IMPORTANT: The 'input_parser_code' should not call the function. The 'output_parser_code' should contain the call to '%s'.
`, language, statementExamples, strings.Join(testCaseInputs, "\n---\n"), funcName, funcName, funcName)

	log.Printf("IO Parse Prompt: %s", prompt)

	// Generate structured output
	jsonOutput, err := GenerateStructuredOutput(ctx, prompt, schema, 0.1)
	if err != nil {
		return nil, fmt.Errorf("failed to generate I/O parse code: %w", err)
	}

	// Unmarshal the JSON string
	var result IOParseResult
	if err := json.Unmarshal([]byte(jsonOutput), &result); err != nil {
		return nil, fmt.Errorf("failed to parse I/O parse code JSON: %w", err)
	}

	return &result, nil
}

// GenerateExpectedOutputs uses a reference solution to generate expected outputs for test cases
func GenerateExpectedOutputs(ctx context.Context, problemStatement string, problemDetails *ProblemDetails, testCases map[string]interface{}, language string, problemID string, problemTitle string) (map[string]map[string]string, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	log.Println("Step 1: Generating I/O parsing code...")

	// The incoming testCases map might be {"test_cases": {...}} or just {...}
	cases, ok := testCases["test_cases"].(map[string]interface{})
	if !ok {
		// It might also be a slice of interfaces from structured generation
		if nestedCases, ok := testCases["test_cases"].([]interface{}); ok {
			cases = make(map[string]interface{})
			for _, item := range nestedCases {
				if itemMap, ok := item.(map[string]interface{}); ok {
					if name, ok := itemMap["name"].(string); ok {
						cases[name] = itemMap
					}
				}
			}
		} else {
			cases = testCases // Assume it's the root map
		}
	}

	var generatedTestCases []map[string]interface{}

	// This case is for when we generate test cases from scratch and need to create the inputs first.
	// If testCases is nil or empty, we must generate them.
	if len(cases) == 0 {
		log.Println("No test cases provided, generating them now...")
		generated, err := GenerateTestCases(ctx, problemStatement, "") // Assuming no constraints for now
		if err != nil {
			return nil, fmt.Errorf("failed to generate test cases: %w", err)
		}
		generatedTestCases = generated
		log.Printf("Successfully generated %d test cases.", len(generatedTestCases))
	} else {
		// Convert the old map format to the new slice format
		for name, testData := range cases {
			if testCaseMap, ok := testData.(map[string]interface{}); ok {
				// Try to extract an ID from the name
				idStr := strings.TrimPrefix(name, "test_case_")
				id, _ := strconv.Atoi(idStr)
				testCaseMap["id"] = id
				generatedTestCases = append(generatedTestCases, testCaseMap)
			}
		}
	}

	// Extract the first 3 test case inputs
	var sampleInputs []string
	i := 0
	for _, testData := range generatedTestCases {
		if i >= 3 {
			break
		}
		inputs, ok := testData["inputs"].(map[string]interface{})
		if !ok {
			continue
		}

		jsonBytes, err := json.Marshal(inputs)
		if err != nil {
			log.Printf("Failed to marshal inputs map to JSON for sample: %v", err)
			continue
		}
		sampleInputs = append(sampleInputs, string(jsonBytes))
		i++
	}

	if len(sampleInputs) == 0 {
		return nil, fmt.Errorf("could not find any valid sample inputs to generate I/O code")
	}

	// Parse examples from the problem statement to provide more context
	statementExamples := parseStatementExamples(problemStatement)
	var statementExamplesStrBuilder strings.Builder
	for i, ex := range statementExamples {
		statementExamplesStrBuilder.WriteString(fmt.Sprintf("Example %d:\nInput:\n%s\nOutput:\n%s\n", i+1, ex.Input, ex.Output))
		if i < len(statementExamples)-1 {
			statementExamplesStrBuilder.WriteString("---\n")
		}
	}
	statementExamplesStr := statementExamplesStrBuilder.String()

	// Generate the I/O parsing code and function signature
	ioParseResult, err := GenerateIOParseCode(ctx, sampleInputs, language, problemTitle, statementExamplesStr)
	if err != nil {
		return nil, fmt.Errorf("failed to generate I/O parsing code: %w", err)
	}
	log.Printf("Successfully generated I/O parsing code. Function signature: %s", ioParseResult.FunctionSignature)

	// Step 2: Generate a correct solution, with a fallback to brute-force.
	log.Println("Step 2: Generating a correct solution...")
	solutionResult, err := GenerateCorrectSolution(ctx, problemStatement, language, ioParseResult.FunctionSignature)
	if err != nil {
		log.Printf("Correct solution generation failed: %v. Falling back to brute-force.", err)
		solutionResult, err = GenerateBruteForceSolution(ctx, problemStatement, language, ioParseResult.FunctionSignature)
		if err != nil {
			return nil, fmt.Errorf("brute-force solution generation also failed: %w", err)
		}
	}
	log.Printf("Successfully generated a solution. Function name: %s", solutionResult.FunctionName)

	// --- Start Debugging Logs ---
	log.Println("--- DEBUG: Generated Code Components ---")
	log.Printf("[Input Parser Code]:\n%s", ioParseResult.InputParserCode)
	log.Printf("[Function Signature]:\n%s", ioParseResult.FunctionSignature)
	log.Printf("[Solution Code]:\n%s", solutionResult.SolutionCode)
	log.Printf("[Output Parser Code]:\n%s", ioParseResult.OutputParserCode)
	log.Println("--- END DEBUG ---")

	// Step 4: Execute the combined code for each test case to get the expected output
	log.Println("Step 4: Executing code to generate expected outputs...")
	generatedOutputs := make(map[string]map[string]string)

	for _, testData := range generatedTestCases {
		idFloat, ok := testData["id"].(float64) // JSON numbers are float64
		if !ok {
			idInt, ok2 := testData["id"].(int)
			if !ok2 {
				log.Printf("Skipping test case due to invalid or missing 'id'")
				continue
			}
			idFloat = float64(idInt)
		}
		testName := fmt.Sprintf("test_case_%.0f", idFloat)

		inputs, ok := testData["inputs"].(map[string]interface{})
		if !ok {
			log.Printf("Skipping test case %s due to invalid input format", testName)
			continue
		}

		inputBytes, err := json.Marshal(inputs)
		if err != nil {
			log.Printf("Failed to marshal input value for test case %s: %v", testName, err)
			continue
		}
		input := string(inputBytes)

		// Assemble the final script
		script := fmt.Sprintf(
			`
# ====== PARSER CODE ======
%s
# ====== SOLUTION FUNCTION ======
%s
# ====== OUTPUT CODE ======
%s
`,
			ioParseResult.InputParserCode,
			solutionResult.SolutionCode,
			ioParseResult.OutputParserCode,
		)

		log.Printf("Input given to executor: %s", input)
		output, err := ExecuteCodeInExecutor(ctx, script, language, input) // Input is sent to stdin

		var finalOutput string
		if err != nil {
			log.Printf("Error executing test case %s: %v. Skipping.", testName, err)
			finalOutput = fmt.Sprintf("<execution-error: %v>", err)
		} else {
			finalOutput = strings.TrimSpace(output)
		}

		generatedOutputs[testName] = map[string]string{
			"input":  input,
			"output": finalOutput,
		}
	}

	// In a goroutine, save the generated code, problem details, and test cases
	go func() {
		bgCtx := context.Background()

		// Save generated code
		if err := database.SaveGeneratedCode(bgCtx, problemID, language, ioParseResult.InputParserCode, solutionResult.SolutionCode, ioParseResult.OutputParserCode); err != nil {
			log.Printf("Error saving generated code to database: %v", err)
		}

		// Save problem details and then test cases
		if problemDetails != nil {
			problemToSave := models.Problem{
				ProblemID:       problemDetails.ProblemID,
				Title:           problemDetails.Title,
				Difficulty:      problemDetails.Difficulty,
				Statement:       problemDetails.FormattedStatement,
				ConstraintsText: problemDetails.Constraints,
				Tags:            problemDetails.Tags,
				TimeLimitMs:     2000,
				MemoryLimitMB:   256,
			}
			if err := database.SaveProblem(bgCtx, &problemToSave); err != nil {
				log.Printf("Error saving problem details to database: %v", err)
				return // Can't save test cases if problem failed
			}

			// Get the newly saved problem to retrieve its ObjectID
			var savedProblem models.Problem
			problemsCollection := database.GetCollection("OJ", "problems")
			if err := problemsCollection.FindOne(bgCtx, bson.M{"problem_id": problemDetails.ProblemID}).Decode(&savedProblem); err != nil {
				log.Printf("Error fetching saved problem to get ID for test cases: %v", err)
				return
			}

			// Prepare test cases for insertion
			var testCasesToSave []interface{}
			keys := make([]string, 0, len(generatedOutputs))
			for k := range generatedOutputs {
				keys = append(keys, k)
			}
			sort.Slice(keys, func(i, j int) bool {
				numI, _ := strconv.Atoi(strings.TrimPrefix(keys[i], "test_case_"))
				numJ, _ := strconv.Atoi(strings.TrimPrefix(keys[j], "test_case_"))
				return numI < numJ
			})

			for i, key := range keys {
				testData := generatedOutputs[key]
				isSample := (i < 3) // Mark first 3 test cases as samples

				tc := models.TestCase{
					ProblemDBID:    savedProblem.ID,
					Input:          testData["input"],
					ExpectedOutput: testData["output"],
					IsSample:       isSample,
					Points:         1,
					Notes:          key,
					SequenceNumber: i + 1,
					CreatedAt:      time.Now(),
				}
				testCasesToSave = append(testCasesToSave, tc)
			}

			if len(testCasesToSave) > 0 {
				testCasesCollection := database.GetCollection("OJ", "test_cases")
				if _, err := testCasesCollection.InsertMany(bgCtx, testCasesToSave); err != nil {
					log.Printf("Error saving test cases to database: %v", err)
				} else {
					log.Printf("Successfully saved %d test cases for problem %s", len(testCasesToSave), problemDetails.ProblemID)
				}
			}
		}
	}()

	log.Printf("Successfully generated %d expected outputs.", len(generatedOutputs))
	return generatedOutputs, nil
}

// ExecuteCodeInExecutor calls the executor service with a self-contained script.
func ExecuteCodeInExecutor(ctx context.Context, code, language, input string) (string, error) {
	// The new approach creates a full script, so functionName and input are not needed at this level.
	log.Printf("Executing code in executor: %s", code)
	log.Printf("Language: %s", language)
	log.Printf("Input: %s", TruncateForLogging(input, 1000))
	result, err := ExecuteCode(language, code, input)
	if err != nil {
		return "", fmt.Errorf("execution failed: %w", err)
	}

	if result.Status != "success" {
		// Combine output and error for better debugging in logs. The error returned to the caller is cleaner.
		log.Printf("Execution failed with status %s. Output: %s", result.Status, result.Output)
		return "", fmt.Errorf("execution failed with status %s", result.Status)
	}

	return result.Output, nil
}

// GenerateProblemDetails uses the AI model to generate structured problem details
func GenerateProblemDetails(ctx context.Context, rawProblemStatement string) (*ProblemDetails, error) {
	if client == nil {
		return nil, fmt.Errorf("AI client not initialized")
	}

	// Create a prompt for the AI to generate problem details
	prompt := fmt.Sprintf(`
You are an expert in competitive programming problems. Based on the raw problem statement provided,
generate a well-structured problem with appropriate details.

Raw problem statement:
"""
%s
"""

Create a complete problem with the following elements:

1. Title: A concise, descriptive title for the problem.
2. Formatted Statement: A well-structured problem statement with a clear description, followed by 2-4 illustrative examples that clarify the problem's requirements and edge cases. Each example must have an input, the expected output, and a detailed explanation.
3. Difficulty: Categorize as "Easy", "Medium", or "Hard" based on algorithmic complexity and expected solution time.
4. Constraints: Technical constraints for input parameters (e.g., array length limits, value ranges).
5. Tags: 2-4 relevant algorithmic tags (e.g., "Array", "Dynamic Programming", "Graph", "Binary Search", etc.).
6. Problem ID: A kebab-case identifier derived from the title (e.g., "two-sum" for "Two Sum").

Format your response as a JSON object with these exact keys:
{
  "title": "Problem Title",
  "formatted_statement": "Clear problem statement with examples",
  "difficulty": "Easy|Medium|Hard",
  "constraints": "1 <= n <= 10^5\\n-10^9 <= nums[i] <= 10^9",
  "tags": ["Tag1", "Tag2"],
  "problem_id": "kebab-case-id"
}
`, rawProblemStatement)

	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate problem details: %w", err)
	}

	log.Printf("Problem details response: %s", resp.Candidates[0].Content.Parts[0].(genai.Text))

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content in AI response for problem details generation")
	}

	// Extract the JSON response
	jsonContent, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return nil, fmt.Errorf("AI response is not text")
	}

	// Clean the response: extract JSON object from the response
	cleanedJSON := strings.TrimSpace(string(jsonContent))

	// Find the JSON object in the response
	startIdx := strings.Index(cleanedJSON, "{")
	endIdx := strings.LastIndex(cleanedJSON, "}")

	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		return nil, fmt.Errorf("failed to extract JSON from AI response")
	}

	jsonStr := cleanedJSON[startIdx : endIdx+1]

	// Unmarshal the JSON string into a struct
	var problemDetails ProblemDetails
	if err := json.Unmarshal([]byte(jsonStr), &problemDetails); err != nil {
		return nil, fmt.Errorf("failed to parse problem details JSON: %w", err)
	}

	// Validate essential fields
	if problemDetails.Title == "" || problemDetails.FormattedStatement == "" || problemDetails.Difficulty == "" {
		return nil, fmt.Errorf("AI generated incomplete problem details")
	}

	// Ensure difficulty is one of the expected values
	problemDetails.Difficulty = strings.Title(strings.ToLower(problemDetails.Difficulty))
	if problemDetails.Difficulty != "Easy" && problemDetails.Difficulty != "Medium" && problemDetails.Difficulty != "Hard" {
		problemDetails.Difficulty = "Medium" // Default to Medium if unexpected value
	}

	// Generate problem ID if not provided or invalid
	if problemDetails.ProblemID == "" {
		// Convert title to kebab-case
		problemDetails.ProblemID = strings.ToLower(problemDetails.Title)
		problemDetails.ProblemID = strings.ReplaceAll(problemDetails.ProblemID, " ", "-")
		// Remove any non-alphanumeric characters except hyphens
		reg := regexp.MustCompile("[^a-z0-9-]")
		problemDetails.ProblemID = reg.ReplaceAllString(problemDetails.ProblemID, "")
		// Replace multiple hyphens with a single one
		reg = regexp.MustCompile("-+")
		problemDetails.ProblemID = reg.ReplaceAllString(problemDetails.ProblemID, "-")
		// Trim hyphens from start and end
		problemDetails.ProblemID = strings.Trim(problemDetails.ProblemID, "-")
	}

	problemDetails.ProblemID = createUniqueProblemID(problemDetails.ProblemID)

	return &problemDetails, nil
}

// TruncateForLogging truncates a long string for logging purposes
func TruncateForLogging(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}

	// Keep the first and last parts of the string
	firstPart := maxLen / 2
	lastPart := maxLen / 2

	// Ensure we don't have a negative length if maxLen is small
	if lastPart > len(s) {
		lastPart = 0
	}
	if firstPart+lastPart > len(s) {
		firstPart = len(s) - lastPart
	}

	return s[:firstPart] + "..." + s[len(s)-lastPart:]
}

// StatementExample holds the input and output for an example from the problem statement.
type StatementExample struct {
	Input  string
	Output string
}

// parseStatementExamples extracts input/output examples from a problem statement's markdown.
func parseStatementExamples(statement string) []StatementExample {
	var examples []StatementExample
	// This regex looks for 'Example', then 'Input:' in a code block, then 'Output:' in a code block.
	re := regexp.MustCompile(`(?is)Example\s*\d+:.*?Input:\s*` + "```" + `\s*([\s\S]+?)\s*` + "```" + `.*?Output:\s*` + "```" + `\s*([\s\S]+?)\s*` + "```")
	matches := re.FindAllStringSubmatch(statement, -1)

	for _, match := range matches {
		if len(match) == 3 {
			examples = append(examples, StatementExample{
				Input:  strings.TrimSpace(match[1]),
				Output: strings.TrimSpace(match[2]),
			})
		}
	}
	return examples
}

// fixPythonExpressions handles Python expressions in the test cases JSON
// by marking them as Python-generated and simplifying the input
func fixPythonExpressions(jsonStr string) string {
	// Detect complex Python expressions (list comprehensions, join, etc.)
	reComplexPython := regexp.MustCompile(`"input"\s*:\s*"('.*?join\(.*?\)|.*?for\s+.*?\s+in\s+.*?)"`)
	jsonStr = reComplexPython.ReplaceAllString(jsonStr, `"input": "$1", "python": true`)

	// Handle string repetition with concatenation in quotes (e.g., 'a' * 100000 + 'b')
	reQuotedMultConcat := regexp.MustCompile(`"input"\s*:\s*"'([^']+)'\s*\*\s*(\d+)\s*\+\s*'([^']+)'"`)
	jsonStr = reQuotedMultConcat.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the strings and repetition count
		parts := reQuotedMultConcat.FindStringSubmatch(match)
		if len(parts) < 4 {
			return match
		}

		// Parse the repetition count
		count, err := strconv.Atoi(parts[2])
		if err != nil {
			return match
		}

		// Limit the repetition to avoid memory issues (50MB max)
		if count > 50000000/len(parts[1]) {
			count = 50000000 / len(parts[1])
		}

		// Generate the repeated string and concatenate
		repeated := strings.Repeat(parts[1], count) + parts[3]

		// Return the evaluated result
		return fmt.Sprintf(`"input": "%s"`, repeated)
	})

	// Handle string repetition in quotes (e.g., 'a' * 100000)
	reQuotedMult := regexp.MustCompile(`"input"\s*:\s*"'([^']+)'\s*\*\s*(\d+)"`)
	jsonStr = reQuotedMult.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the string and repetition count
		parts := reQuotedMult.FindStringSubmatch(match)
		if len(parts) < 3 {
			return match
		}

		// Parse the repetition count
		count, err := strconv.Atoi(parts[2])
		if err != nil {
			return match
		}

		// Limit the repetition to avoid memory issues (50MB max)
		if count > 50000000/len(parts[1]) {
			count = 50000000 / len(parts[1])
		}

		// Generate the repeated string
		repeated := strings.Repeat(parts[1], count)

		// Return the evaluated result
		return fmt.Sprintf(`"input": "%s"`, repeated)
	})

	// Handle string concatenation first (more complex pattern)
	reConcat := regexp.MustCompile(`"input"\s*:\s*"([^"]+)"\s*\*\s*\d+\s*\+\s*"([^"]+)"\s*\*\s*\d+`)
	jsonStr = reConcat.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the strings
		parts := reConcat.FindStringSubmatch(match)
		if len(parts) < 3 {
			return match
		}

		// Replace with a simplified version and set python flag to true
		return fmt.Sprintf(`"input": "%s%s", "python": true`, parts[1], parts[2])
	})

	// Then handle simple string multiplication
	reMult := regexp.MustCompile(`"input"\s*:\s*"([^"]+)"\s*\*\s*\d+`)
	jsonStr = reMult.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the string
		parts := reMult.FindStringSubmatch(match)
		if len(parts) < 2 {
			return match
		}

		// Replace with a simplified version and set python flag to true
		return fmt.Sprintf(`"input": "%s", "python": true`, parts[1])
	})

	// Remove any existing python: false that might still be present
	jsonStr = regexp.MustCompile(`"python"\s*:\s*false`).ReplaceAllString(jsonStr, "")

	// Clean up any double commas that might have been created
	jsonStr = regexp.MustCompile(`,\s*,`).ReplaceAllString(jsonStr, ",")

	// Fix trailing commas before closing braces
	jsonStr = regexp.MustCompile(`,\s*\}`).ReplaceAllString(jsonStr, "}")

	// Fix trailing commas before closing brackets
	jsonStr = regexp.MustCompile(`,\s*\]`).ReplaceAllString(jsonStr, "]")

	// Handle any other invalid characters that might appear in the JSON
	jsonStr = regexp.MustCompile(`[^\x20-\x7E]`).ReplaceAllString(jsonStr, "")

	return jsonStr
}
